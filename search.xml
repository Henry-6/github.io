<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[list的Comparator排序]]></title>
    <url>%2F2018%2F05%2F18%2Flist%E7%9A%84Comparator%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[随着数据的增多，list的使用也就会更多。在某些时候，数据需要按照一定的序列来重新排序，这时候就可以使用到Comparator。 Comparator本身是一个在类的外部使用的排序，Comparable是在类的内部使用的排序，由于笔者只使用了Comparator排序，所以现在还是只写Comparator排序的基本内容。老规矩，先上代码 12345678910111213private class IntegerComparable implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer t1, Integer t2) &#123; if (t1 &gt; t2) &#123; return 1; &#125; else if (t1 &lt; t2) &#123; return -1; &#125; return 0; &#125;&#125; Comparator类只需要继承compare方法就可以实现比较的功能，Integer是比较的参数，可以为自定义的实体类。compare方法返回1则是把t2放到t1前面，返回-1则是t1放在t2前面，返回0则是不变，意思就是t1等于t2 要使用这个继承类只需要一行代码1Collections.sort(List, new IntegerComparable()); List经过这个方法处理之后就会重新修改其排序，这时候挨个取就会发现顺序是按照自己定义的顺序排列了。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>List</tag>
        <tag>Comparator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android设备外接扫描枪]]></title>
    <url>%2F2018%2F04%2F05%2FAndroid%E8%AE%BE%E5%A4%87%E5%A4%96%E6%8E%A5%E6%89%AB%E6%8F%8F%E6%9E%AA%2F</url>
    <content type="text"><![CDATA[最近项目中有扫码的需求，但是由于Android设备是一个pad，拿起来扫条码不太方便，于是需要外接一个蓝牙扫描枪。现在市面上的蓝牙扫描枪连接在Android设备上之后都显示为一个外接键盘，有部分扫描枪会自动加入回车符，这是因为扫描枪的设置中是会自动加入回车符。一般虽然这个回车符可以通过修改扫描枪的设置而去掉，但是每次连接一个扫描枪还要将扫描枪设置一番未免太过于麻烦，于是还不如在未将数据打印出来之前将数据拦截，自己控制数据应怎样处理 首先上代码 实体类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothClass;import android.bluetooth.BluetoothDevice;import android.os.Handler;import android.view.InputDevice;import android.view.KeyEvent;import java.util.Iterator;import java.util.Set;/** * Created by dell on 2018/5/29. */public class ScanGunKeyEventHelper &#123; private final static long MESSAGE_DELAY = 500;//延迟500ms，判断扫码是否完成。 private StringBuffer mStringBufferResult;//扫码内容 private boolean mCaps;//大小写区分 private final Handler mHandler; private final BluetoothAdapter mBluetoothAdapter; private final Runnable mScanningFishedRunnable; private OnScanSuccessListener mOnScanSuccessListener; private String mDeviceName; public ScanGunKeyEventHelper(OnScanSuccessListener onScanSuccessListener) &#123; mOnScanSuccessListener = onScanSuccessListener ; mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); mStringBufferResult = new StringBuffer(); mHandler = new Handler(); mScanningFishedRunnable = new Runnable() &#123; @Override public void run() &#123; performScanSuccess(); &#125; &#125;; &#125; /** * 返回扫码成功后的结果 */ private void performScanSuccess() &#123; String barcode = mStringBufferResult.toString(); if (mOnScanSuccessListener != null) mOnScanSuccessListener.onScanSuccess(barcode); mStringBufferResult.setLength(0); &#125; /** * 扫码枪事件解析 * @param event */ public void analysisKeyEvent(KeyEvent event) &#123; int keyCode = event.getKeyCode(); //字母大小写判断 checkLetterStatus(event); if (event.getAction() == KeyEvent.ACTION_DOWN) &#123; char aChar = getInputCode(event);; if (aChar != 0) &#123; mStringBufferResult.append(aChar); &#125; if (keyCode == KeyEvent.KEYCODE_ENTER) &#123; //若为回车键，直接返回 mHandler.removeCallbacks(mScanningFishedRunnable); mHandler.post(mScanningFishedRunnable); &#125; else &#123; //延迟post，若500ms内，有其他事件 mHandler.removeCallbacks(mScanningFishedRunnable); mHandler.postDelayed(mScanningFishedRunnable, MESSAGE_DELAY); &#125; &#125; &#125; //检查shift键 private void checkLetterStatus(KeyEvent event) &#123; int keyCode = event.getKeyCode(); if (keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT || keyCode == KeyEvent.KEYCODE_SHIFT_LEFT) &#123; if (event.getAction() == KeyEvent.ACTION_DOWN) &#123; //按着shift键，表示大写 mCaps = true; &#125; else &#123; //松开shift键，表示小写 mCaps = false; &#125; &#125; &#125; //获取扫描内容 private char getInputCode(KeyEvent event) &#123; int keyCode = event.getKeyCode(); char aChar; if (keyCode &gt;= KeyEvent.KEYCODE_A &amp;&amp; keyCode &lt;= KeyEvent.KEYCODE_Z) &#123; //字母 aChar = (char) ((mCaps ? 'A' : 'a') + keyCode - KeyEvent.KEYCODE_A); &#125; else if (keyCode &gt;= KeyEvent.KEYCODE_0 &amp;&amp; keyCode &lt;= KeyEvent.KEYCODE_9) &#123; //数字 aChar = (char) ('0' + keyCode - KeyEvent.KEYCODE_0); &#125; else &#123; //其他符号 switch (keyCode) &#123; case KeyEvent.KEYCODE_PERIOD: aChar = '.'; break; case KeyEvent.KEYCODE_MINUS: aChar = mCaps ? '_' : '-'; break; case KeyEvent.KEYCODE_SLASH: aChar = '/'; break; case KeyEvent.KEYCODE_BACKSLASH: aChar = mCaps ? '|' : '\\'; break; default: aChar = 0; break; &#125; &#125; return aChar; &#125; public interface OnScanSuccessListener &#123; void onScanSuccess(String barcode); &#125; public void onDestroy() &#123; mHandler.removeCallbacks(mScanningFishedRunnable); mOnScanSuccessListener = null; &#125; //部分手机如三星，无法使用该方法// private void hasScanGun() &#123;// Configuration cfg = getResources().getConfiguration();// return cfg.keyboard != Configuration.KEYBOARD_NOKEYS;// &#125; /** * 扫描枪是否连接 * @return */ public boolean hasScanGun() &#123; if (mBluetoothAdapter == null) &#123; return false; &#125; Set&lt;BluetoothDevice&gt; blueDevices = mBluetoothAdapter.getBondedDevices(); if (blueDevices == null || blueDevices.size() &lt;= 0) &#123; return false; &#125; for (Iterator&lt;BluetoothDevice&gt; iterator = blueDevices.iterator(); iterator.hasNext(); ) &#123; BluetoothDevice bluetoothDevice = iterator.next(); if (bluetoothDevice.getBluetoothClass().getMajorDeviceClass() == BluetoothClass.Device.Major.PERIPHERAL) &#123; mDeviceName = bluetoothDevice.getName(); return isInputDeviceExist(mDeviceName); &#125; &#125; return false; &#125; /** * 输入设备是否存在 * @param deviceName * @return */ private boolean isInputDeviceExist(String deviceName) &#123; int[] deviceIds = InputDevice.getDeviceIds(); for (int id : deviceIds) &#123; if (InputDevice.getDevice(id).getName().equals(deviceName)) &#123; return true; &#125; &#125; return false; &#125; /** * 是否为扫码枪事件(部分机型KeyEvent获取的名字错误) * @param event * @return */ @Deprecated public boolean isScanGunEvent(KeyEvent event) &#123; return event.getDevice().getName().equals(mDeviceName); &#125;&#125; 使用方法先在activity中添加监听方法，将扫描枪扫描的数据拦截下来，交给helper处理12345678910111213/** * 截获按键事件.发给ScanGunKeyEventHelper * @param event * @return */@Overridepublic boolean dispatchKeyEvent(KeyEvent event) &#123; if (scanHelper.isScanGunEvent(event)) &#123; scanHelper.analysisKeyEvent(event); return true; &#125; return super.dispatchKeyEvent(event);&#125; 再实现扫描枪的回调接口123456private ScanGunKeyEventHelper.OnScanSuccessListener onScanSuccessListener = new ScanGunKeyEventHelper.OnScanSuccessListener() &#123; @Override public void onScanSuccess(String barcode) &#123; /** do something **/ &#125;&#125;; 然后实例化出一个对象1ScanGunKeyEventHelper scanHelper = new ScanGunKeyEventHelper(onScanSuccessListener); 在onResume里监测一下是否连接上了扫描枪123if (!scanHelper.hasScanGun()) &#123; /** do something **/&#125; 最后记得在onDestroy中注销一下扫描枪的进程123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); //注销扫描枪 scanHelper.onDestroy();&#125; 这时候扫描枪的数据就会被拦截到回调接口中去了，需要怎么处理数据，由你说了算！]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成Git SSH 公钥]]></title>
    <url>%2F2018%2F01%2F05%2F%E7%94%9F%E6%88%90Git%20SSH%20%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。于是记录一下生成密钥和查询密钥key的指令 首先应该先安装gitWindows下载链接 Mac下载链接 SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录1234$ cd ~/.ssh$ lsauthorized_keys2 id_dsa known_hostsconfig id_dsa.pub 如果没有该目录下的id_dsa和id_dsa.pub或者目录都没有，说明需要创建密钥1$ ssh-keygen 一般一直回车下去就可以了，有时候需要输入yes，最后会在上文提到的ssh目录下生成密钥这时候可以查看公钥了1$ cat ~/.ssh/id_rsa.pub 终端会打印出一串字符，这就是公钥了，自己添加到远程仓库或者是给你的管理员吧，例：ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local]]></content>
      <tags>
        <tag>SSH</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用keytool获取密钥证书指纹 (SHA1)]]></title>
    <url>%2F2017%2F09%2F13%2F%E4%BD%BF%E7%94%A8keytool%E8%8E%B7%E5%8F%96%E5%AF%86%E9%92%A5%E8%AF%81%E4%B9%A6%E6%8C%87%E7%BA%B9%20(SHA1)%2F</url>
    <content type="text"><![CDATA[哎，项目注册上架的时候，经常需要用到key的密钥，这密钥又长又不好记，还经常忘记keytool怎么查询密码，特记录 keytool是jdk自带工具，在配置jdk/bin环境后即可以使用。 1.找到密钥证书所在目录 2.cd到密钥证书所在目录 3.输入keytool -list -keystore xxx,输入密钥密码]]></content>
      <tags>
        <tag>keytool</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Facebook 第三方登录并上传360全景图片]]></title>
    <url>%2F2017%2F08%2F07%2FAndroid%20Studio%20Facebook%20%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E5%B9%B6%E4%B8%8A%E4%BC%A0360%E5%85%A8%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[最近全景系列慢慢的变火了，但是博主在尝试写上传全景图片到facebook的时候并搜索不到相关的资料，官方文档和谷歌都搜索不到什么上传全景图片使用的api或者其他信息（各种全景设备的软文倒是有一大堆），所以在博主查找各种资料，奋斗了两个星期后，终于找到了一套的解决办法，现在给大家分享分享。 使用SDK首先在使用facebook的官方api上传之前需要去使用facebook的sdk,在build.gradle中添加“compile ‘com.facebook.android:facebook-android-sdk:4.+’”，这样可以保证sdk是最新的，如图： 在facebook注册应用到https://developers.facebook.com/ 登录并成为开发者，然后添加新应用，如图： 填写应用信息类名是进入时候第一个启动的activity，密钥散列需要特别说明下，它是根据你的应用的签名打包之后安装才能得到的一串英文和数字，获取方法一搜一大堆，我就说一个简单的方法 下载链接apk并安装：下载 打包签名并安装你需要接入Facebook的应用 输入你的应用的包名，得到一串英文和数字即为密钥散列 配置环境和登录获取权限在撸代码之前，其实还有2个操作，分别是： 配置Facebook SDK使用的环境 Facebook登录并获取到对应的权限 这个可以按照Facebook官方的文档提示来：在AndroidManifest.xml添加配置 配置好后可以选择用Facebook提供的集成的登录按钮登录（官方集成按钮文档），也可以自己写登录代码实现登录 第三方登录流程： 首先要初始化Facebook工具 然后写管理回调器和登录的代码 记得要写facebookCallback（登录的回调） 官方的回调很清晰，这里就不多说，贴图就好 最后一定不能漏的，博主漏了这个不能登录，排查了好久才发现 到这里，就可以正常的登录并获取到发布帖子的权限了 博主还遇到过一个问题：在Facebook中还有一个叫”user_photos”的权限，博主以为发布图片需要，后来在审核的时候，Facebook客服告诉我不需要此权限就可以上传图片，所以各位就只需要申请”publish_actions”权限即可。 正文代码获取到发帖的权限后，就可以上传我们的全！景！图！片！了！直接上代码：123456789101112131415161718192021222324252627282930313233343536//全景照片Bundle封装的数据Bundle params = new Bundle(); try &#123; //是否是全景照片 params.putBoolean("allow_spherical_photo", true); //初始视距水平度 params.putInt("initial_view_heading_override_degrees", 0); //初始视距俯仰度 params.putInt("initial_view_pitch_override_degrees", 0); //公开等级ALL_FRIENDS,CUSTOM,EVERYONE,FRIENDS_OF_FRIENDS,SELF; params.putString("privacy", "&#123;\"value\":\"EVERYONE\"&#125;"); //描述 params.putString("caption", commentShare); //文件的绝对路径 params.putByteArray("source", getResource(pathShare)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //AsyncTask异步发送数据给Facebook new GraphRequest( AccessToken.getCurrentAccessToken(), "/me/photos", params, HttpMethod.POST, new GraphRequest.Callback() &#123; @Override public void onCompleted(GraphResponse response) &#123; //返回的情况 Log.d("graphRequestAsyncTask", "返回的情况 response = " + response); //上传图片得到的图片信息 Log.d("getRawResponse", "上传图片得到的图片信息 getRawResponse = " + response.getRawResponse()); //获取返回的错误原因 Log.d("getError", "获取返回的错误原因 getError = " + response.getError()); &#125; &#125; ).executeAsync(); 然后就等着图片上传完成，就可以到Facebook去查看刚刚上传的全景图片了。有这个箭头指的东东就说明上传的是全景图片啦！ 在最后面补上我写的一个小demo吧，这样大家看起来也就清晰很多了上方的代码和SDK都在里面了，只需要修改一下应用的id，包名，类名就可以直接使用啦！ demo下载 有什么不明白的或者是不足之处大家留言就好，博主看到之后会回答和补充的。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>PANO</tag>
        <tag>Android Studio</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio使用mp4parser进行视频的分割]]></title>
    <url>%2F2017%2F03%2F20%2FAndroid%20Studio%E4%BD%BF%E7%94%A8mp4parser%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91%E7%9A%84%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[前阵子项目突然需要视频编辑功能，趴在墙上搜索了一番，发现了MP4 Parser这个框架，看了一下觉得比较简单，于是取出源代码稍稍加工，直接放入了项目，并做下记录 MP4 Parser 1.1 MP4 ParserMP4 Parser是GitHub上开源的一个视频处理项目。GitHub链接 1.2功能及使用场景使用该项目能实现视频剪切、视频合并、视频转码等效果。在本博客中，只对视频编辑代码进行讲解，在你的项目中加入开源项目的核心代码后，即可对视频文件进行剪辑处理。 下载导入 2.1 下载流程1) 先进入https://github.com/sannies/mp4parser 地址 2) 点击如下图按钮 3) 点击如下图按钮 4) 选择如下图文件下载 5)将下载下来的jar包放入项目的libs文件夹下 6) 在build.gradle中添加框中的代码 7) 在AndroidManifest.xml中添加框中的权限 视频编辑代码 3.1 源码中的剪辑视频例子gitHub仓库源码中的视频剪辑例子 3.2 源码中的剪辑视频代码中文解释1) 代码块1—-对需要剪辑的视频的开始时间和结束时间进行校正 2) 代码块二—-根据校正后的时间得到剪辑开始和结束的位置 3) 代码块三—-根据剪辑开始和结束的位置保存视频 3.3 基于源码的剪辑代码VideoClip类使用方法1) 实例化VideoClip类VideoClip videoClip = new VideoClip(); 2) 设置被编辑视频的文件路径videoClip.setFilePath(url); 3) 设置被编辑的视频输出路径videoClip.setWorkingPath(out_path); 4) 设置剪辑开始的时间videoClip.setStartTime(start_time); 5) 设置剪辑结束的时间videoClip.setEndTime(end_time); 6) 设置输出的文件名称videoClip.setOutName(out_name); 7) 调用剪辑并保存视频文件方法（建议作为点击保存时的操作并加入等待对话框）videoClip.clip(); 基于源码的视频剪辑代码 VideoClip.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import com.R; import com.coremedia.iso.boxes.Container; import com.googlecode.mp4parser.authoring.Movie; import com.googlecode.mp4parser.authoring.Track; import com.googlecode.mp4parser.authoring.builder.DefaultMp4Builder; import com.googlecode.mp4parser.authoring.container.mp4.MovieCreator; import com.googlecode.mp4parser.authoring.tracks.CroppedTrack; import java.io.File; import java.io.FileOutputStream; import java.nio.channels.FileChannel; import java.util.LinkedList; import java.util.List; /** * @ClassName: VideoClip * @Description: * @version: V2.0 * @Copyright: X-Force * @author: foryou * @Date: 2017/2/20 14:24 */ public class VideoClip &#123; private static final String TAG = "VideoClip"; private String filePath;//视频路径 private String workingPath;//输出路径 private String outName;//输出文件名 private double startTime;//剪切起始时间 private double endTime;//剪切结束时间 public void setFilePath(String filePath) &#123; this.filePath = filePath; &#125; public void setWorkingPath(String workingPath) &#123; this.workingPath = workingPath; &#125; public void setOutName(String outName) &#123; this.outName = outName; &#125; public void setEndTime(double endTime) &#123; this.endTime = endTime / 1000; &#125; public void setStartTime(double startTime) &#123; this.startTime = startTime / 1000; &#125; public void clip() &#123; try &#123; //将要剪辑的视频文件 Movie movie = MovieCreator.build(filePath); List&lt;Track&gt; tracks = movie.getTracks(); movie.setTracks(new LinkedList&lt;Track&gt;()); //时间是否修正 boolean timeCorrected = false; //计算并换算剪切时间 for (Track track : tracks) &#123; if (track.getSyncSamples() != null &amp;&amp; track.getSyncSamples().length &gt; 0) &#123; if (timeCorrected) &#123; throw new RuntimeException( "The startTime has already been corrected by another track with SyncSample. Not Supported."); &#125; //true,false表示短截取；false,true表示长截取 startTime = VideoHelper.correctTimeToSyncSample(track, startTime, false);//修正后的开始时间 endTime = VideoHelper.correctTimeToSyncSample(track, endTime, true); //修正后的结束时间 timeCorrected = true; &#125; &#125; //根据换算到的开始时间和结束时间来截取视频 for (Track track : tracks) &#123; long currentSample = 0; //视频截取到的当前的位置的时间 double currentTime = 0; //视频的时间长度 double lastTime = -1; //上次截取到的最后的时间 long startSample1 = -1; //截取开始的时间 long endSample1 = -1; //截取结束的时间 //设置开始剪辑的时间和结束剪辑的时间 避免超出视频总长 for (int i = 0; i &lt; track.getSampleDurations().length; i++) &#123; long delta = track.getSampleDurations()[i]; if (currentTime &gt; lastTime &amp;&amp; currentTime &lt;= startTime) &#123; startSample1 = currentSample;//编辑开始的时间 &#125; if (currentTime &gt; lastTime &amp;&amp; currentTime &lt;= endTime) &#123; endSample1 = currentSample; //编辑结束的时间 &#125; lastTime = currentTime; //上次截取到的时间（避免在视频最后位置了还在增加编辑结束的时间） currentTime += (double) delta / (double) track.getTrackMetaData().getTimescale();//视频的时间长度 currentSample++; //当前位置+1 &#125; movie.addTrack(new CroppedTrack(track, startSample1, endSample1));// 创建一个新的视频文件 &#125; //合成视频mp4 Container out = new DefaultMp4Builder().build(movie); File storagePath = new File(workingPath); storagePath.mkdirs(); FileOutputStream fos = new FileOutputStream(new File(storagePath, outName)); FileChannel fco = fos.getChannel(); out.writeContainer(fco); //关闭流 fco.close(); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; VideoHelper.java（换算时间使用的工具类，可与VideoClip.java合并）12345678910111213141516171819202122232425262728293031323334353637383940414243444546import com.googlecode.mp4parser.authoring.Track; import java.util.Arrays; /** * @ClassName: VideoHelper * @Description: * @version: V2.0 * @Copyright: X-Force * @author: foryou * @Date: 2017/2/20 14:25 */ public class VideoHelper &#123; /** * 换算剪切时间 */ public static double correctTimeToSyncSample(Track track, double cutHere, boolean next) &#123; double[] timeOfSyncSamples = new double[track.getSyncSamples().length]; long currentSample = 0; double currentTime = 0; for (int i = 0; i &lt; track.getSampleDurations().length; i++) &#123; long delta = track.getSampleDurations()[i]; if (Arrays.binarySearch(track.getSyncSamples(), currentSample + 1) &gt;= 0) &#123; timeOfSyncSamples[Arrays.binarySearch(track.getSyncSamples(), currentSample + 1)] = currentTime; &#125; currentTime += (double) delta / (double) track.getTrackMetaData().getTimescale(); currentSample++; &#125; double previous = 0; for (double timeOfSyncSample : timeOfSyncSamples) &#123; if (timeOfSyncSample &gt; cutHere) &#123; if (next) &#123; return timeOfSyncSample; &#125; else &#123; return previous; &#125; &#125; previous = timeOfSyncSample; &#125; return timeOfSyncSamples[timeOfSyncSamples.length - 1]; &#125; &#125; 在博文结尾附上代码与jar包：地址]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
        <tag>MP4 Parser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式语法]]></title>
    <url>%2F2016%2F12%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[正则表达式是很实用的语法，项目中常常需要使用到，使用起来也比较方便并且实用高效，先记录一些常用方法，以备不时之需。 微软语法解释匹配中文字符的正则表达式： [\u4e00-\u9fa5]评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 匹配双字节字符(包括汉字在内)：[^\x00-\xff]评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：\n\s*\r评注：可以用来删除空白行 匹配HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?&lt;/\1&gt;|&lt;.? /&gt;评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^\s|\s$评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配Email地址的正则表达式：\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*评注：表单验证时很实用 匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$评注：表单验证时很实用 匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}评注：匹配形式如 0511-4405222 或 021-87888822 匹配腾讯QQ号：[1-9][0-9]{4,}评注：腾讯QQ号从10000开始 匹配中国邮政编码：[1-9]\d{5}(?!\d)评注：中国邮政编码为6位数字 匹配身份证：\d{15}|\d{18}评注：中国的身份证为15位或18位 匹配ip地址：\d+.\d+.\d+.\d+评注：提取ip地址时有用 匹配特定数字：^[1-9]\d$ //匹配正整数^-[1-9]\d$ //匹配负整数^-?[1-9]\d$ //匹配整数^[1-9]\d|0$ //匹配非负整数（正整数 + 0）^-[1-9]\d|0$ //匹配非正整数（负整数 + 0）^[1-9]\d.\d|0.\d[1-9]\d$ //匹配正浮点数^-([1-9]\d.\d|0.\d[1-9]\d)$ //匹配负浮点数^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ //匹配浮点数^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d.\d|0.\d[1-9]\d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正 匹配特定字符串：^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^\w+$ //匹配由数字、26个英文字母或者下划线组成的字符串]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASCII字符与URL编码的转义]]></title>
    <url>%2F2016%2F12%2F14%2FASCII%E5%AD%97%E7%AC%A6%E4%B8%8EURL%E7%BC%96%E7%A0%81%E7%9A%84%E8%BD%AC%E4%B9%89%2F</url>
    <content type="text"><![CDATA[URL中的字符只能是ASCII字符，但是ASCII字符比较少，而URL则常常包含ASCII字符集以外的字符，如非英语字符、汉字、特殊符号等等，所以要对URL进行转换。这个过程就叫做URL编码，或者叫URL转义，实质上就是将包含非ASCII字符的URL转换为有效的ASCII字符格式。 ASCII字符与URL编码的对照表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697ASCII字符 URL编码 空格 %20 ! %21 " %22 # %23 $ %24 % %25 &amp; %26 ' %27 ( %28 ) %29 * %2A + %2B , %2C - %2D . %2E / %2F 0 %30 1 %31 2 %32 3 %33 4 %34 5 %35 6 %36 7 %37 8 %38 9 %39 : %3A ; %3B &lt; %3C = %3D &gt; %3E ? %3F @ %40 A %41 B %42 C %43 D %44 E %45 F %46 G %47 H %48 I %49 J %4A K %4B L %4C M %4D N %4E O %4F P %50 Q %51 R %52 S %53 T %54 U %55 V %56 W %57 X %58 Y %59 Z %5A [ %5B \ %5C ] %5D ^ %5E _ %5F ` %60 a %61 b %62 c %63 d %64 e %65 f %66 g %67 h %68 i %69 j %6A k %6B l %6C m %6D n %6E o %6F p %70 q %71 r %72 s %73 t %74 u %75 v %76 w %77 x %78 y %79 z %7A &#123; %7B | %7C &#125; %7D ~ %7E DEL %7F]]></content>
      <tags>
        <tag>转义</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android应用开发SharedPreferences存储数据的使用方法]]></title>
    <url>%2F2016%2F12%2F04%2FAndroid%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91SharedPreferences%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SharedPreferences是Android中最容易理解的数据存储技术，实际上SharedPreferences处理的就是一个key-value（键值对）SharedPreferences常用来存储一些轻量级的数据。 使用SharedPreferences保存数据方法如下：123456789101112//实例化SharedPreferences对象（第一步） SharedPreferences sharedPreferences = getSharedPreferences("test", Activity.MODE_PRIVATE); //实例化SharedPreferences.Editor对象（第二步） SharedPreferences.Editor editor = sharedPreferences.edit(); //用putString的方法保存数据 editor.putString("name", "Karl"); editor.putString("habit", "sleep"); //提交当前数据 editor.commit(); 执行以上代码，SharedPreferences将会把这些数据保存在test.xml文件中，可以在File Explorer的data/data/相应的包名/test.xml 下导出该文件，并查看。 使用SharedPreferences读取数据方法如下：123456//同样，在读取SharedPreferences数据前要实例化出一个SharedPreferences对象 SharedPreferences sharedPreferences= getSharedPreferences("test", Activity.MODE_PRIVATE); // 使用getString方法获得value，注意第2个参数是value的默认值 String name =sharedPreferences.getString("name", ""); String habit =sharedPreferences.getString("habit", ""); 但是实际使用时不可能每个地方都要写一次以上代码，所以还是有一个封装好了的工具链接]]></content>
      <tags>
        <tag>Android</tag>
        <tag>SharedPreferences</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LayoutInflater和inflate()方法的用法 (自定义View中加载xml布局)]]></title>
    <url>%2F2016%2F12%2F03%2FLayoutInflater%E5%92%8Cinflate()%E6%96%B9%E6%B3%95%E7%9A%84%E7%94%A8%E6%B3%95%20(%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%AD%E5%8A%A0%E8%BD%BDxml%E5%B8%83%E5%B1%80)%2F</url>
    <content type="text"><![CDATA[实现LayoutInflater的实例化共有3种方法 1 通过SystemService获得12LayoutInflater inflater = (LayoutInflater)context.getSystemServices(Context.LAYOUT_INFLATER_SERVICES);Viewview = inflater.inflate(R.layout.main, null); 2 从给定的context中获得12LayoutInflater inflater = LayoutInflater.from(context);Viewview = inflater.inflate(R.layout.mian, null); 3 LayoutInflater inflater =getLayoutInflater();（在Activity中可以使用，实际上是View子类下window的一个函数）1Viewlayout = inflater.inflate(R.layout.main, null);]]></content>
      <tags>
        <tag>Android</tag>
        <tag>LayoutInflater</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十六进制颜色大全]]></title>
    <url>%2F2016%2F12%2F03%2F%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[收录了很多十六进制的颜色，要用的时候可以直接复制~~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;color name="white"&gt;#FFFFFF&lt;/color&gt;&lt;!--白色 --&gt; &lt;color name="ivory"&gt;#FFFFF0&lt;/color&gt;&lt;!--象牙色 --&gt; &lt;color name="lightyellow"&gt;#FFFFE0&lt;/color&gt;&lt;!--亮黄色 --&gt; &lt;color name="yellow"&gt;#FFFF00&lt;/color&gt;&lt;!--黄色 --&gt; &lt;color name="snow"&gt;#FFFAFA&lt;/color&gt;&lt;!--雪白色 --&gt; &lt;color name="floralwhite"&gt;#FFFAF0&lt;/color&gt;&lt;!--花白色 --&gt; &lt;color name="lemonchiffon"&gt;#FFFACD&lt;/color&gt;&lt;!--柠檬绸色 --&gt; &lt;color name="cornsilk"&gt;#FFF8DC&lt;/color&gt;&lt;!--米绸色 --&gt; &lt;color name="seashell"&gt;#FFF5EE&lt;/color&gt;&lt;!--海贝色 --&gt; &lt;color name="lavenderblush"&gt;#FFF0F5&lt;/color&gt;&lt;!--淡紫红 --&gt; &lt;color name="papayawhip"&gt;#FFEFD5&lt;/color&gt;&lt;!--番木色 --&gt; &lt;color name="blanchedalmond"&gt;#FFEBCD&lt;/color&gt;&lt;!--白杏色 --&gt; &lt;color name="mistyrose"&gt;#FFE4E1&lt;/color&gt;&lt;!--浅玫瑰色 --&gt; &lt;color name="bisque"&gt;#FFE4C4&lt;/color&gt;&lt;!--桔黄色 --&gt; &lt;color name="moccasin"&gt;#FFE4B5&lt;/color&gt;&lt;!--鹿皮色 --&gt; &lt;color name="navajowhite"&gt;#FFDEAD&lt;/color&gt;&lt;!--纳瓦白 --&gt; &lt;color name="peachpuff"&gt;#FFDAB9&lt;/color&gt;&lt;!--桃色 --&gt; &lt;color name="gold"&gt;#FFD700&lt;/color&gt;&lt;!--金色 --&gt; &lt;color name="pink"&gt;#FFC0CB&lt;/color&gt;&lt;!--粉红色 --&gt; &lt;color name="lightpink"&gt;#FFB6C1&lt;/color&gt;&lt;!--亮粉红色 --&gt; &lt;color name="orange"&gt;#FFA500&lt;/color&gt;&lt;!--橙色 --&gt; &lt;color name="lightsalmon"&gt;#FFA07A&lt;/color&gt;&lt;!--亮肉色 --&gt; &lt;color name="darkorange"&gt;#FF8C00&lt;/color&gt;&lt;!--暗桔黄色 --&gt; &lt;color name="coral"&gt;#FF7F50&lt;/color&gt;&lt;!--珊瑚色 --&gt; &lt;color name="hotpink"&gt;#FF69B4&lt;/color&gt;&lt;!--热粉红色 --&gt; &lt;color name="tomato"&gt;#FF6347&lt;/color&gt;&lt;!--西红柿色 --&gt; &lt;color name="orangered"&gt;#FF4500&lt;/color&gt;&lt;!--红橙色 --&gt; &lt;color name="deeppink"&gt;#FF1493&lt;/color&gt;&lt;!--深粉红色 --&gt; &lt;color name="fuchsia"&gt;#FF00FF&lt;/color&gt;&lt;!--紫红色 --&gt; &lt;color name="magenta"&gt;#FF00FF&lt;/color&gt;&lt;!--红紫色 --&gt; &lt;color name="red"&gt;#FF0000&lt;/color&gt;&lt;!--红色 --&gt; &lt;color name="oldlace"&gt;#FDF5E6&lt;/color&gt;&lt;!--老花色 --&gt; &lt;color name="lightgoldenrodyellow"&gt;#FAFAD2&lt;/color&gt;&lt;!--亮金黄色 --&gt; &lt;color name="linen"&gt;#FAF0E6&lt;/color&gt;&lt;!--亚麻色 --&gt; &lt;color name="antiquewhite"&gt;#FAEBD7&lt;/color&gt;&lt;!--古董白 --&gt; &lt;color name="salmon"&gt;#FA8072&lt;/color&gt;&lt;!--鲜肉色 --&gt; &lt;color name="ghostwhite"&gt;#F8F8FF&lt;/color&gt;&lt;!--幽灵白 --&gt; &lt;color name="mintcream"&gt;#F5FFFA&lt;/color&gt;&lt;!--薄荷色 --&gt; &lt;color name="whitesmoke"&gt;#F5F5F5&lt;/color&gt;&lt;!--烟白色 --&gt; &lt;color name="beige"&gt;#F5F5DC&lt;/color&gt;&lt;!--米色 --&gt; &lt;color name="wheat"&gt;#F5DEB3&lt;/color&gt;&lt;!--浅黄色 --&gt; &lt;color name="sandybrown"&gt;#F4A460&lt;/color&gt;&lt;!--沙褐色 --&gt; &lt;color name="azure"&gt;#F0FFFF&lt;/color&gt;&lt;!--天蓝色 --&gt; &lt;color name="honeydew"&gt;#F0FFF0&lt;/color&gt;&lt;!--蜜色 --&gt; &lt;color name="aliceblue"&gt;#F0F8FF&lt;/color&gt;&lt;!--艾利斯兰 --&gt; &lt;color name="khaki"&gt;#F0E68C&lt;/color&gt;&lt;!--黄褐色 --&gt; &lt;color name="lightcoral"&gt;#F08080&lt;/color&gt;&lt;!--亮珊瑚色 --&gt; &lt;color name="palegoldenrod"&gt;#EEE8AA&lt;/color&gt;&lt;!--苍麒麟色 --&gt; &lt;color name="violet"&gt;#EE82EE&lt;/color&gt;&lt;!--紫罗兰色 --&gt; &lt;color name="darksalmon"&gt;#E9967A&lt;/color&gt;&lt;!--暗肉色 --&gt; &lt;color name="lavender"&gt;#E6E6FA&lt;/color&gt;&lt;!--淡紫色 --&gt; &lt;color name="lightcyan"&gt;#E0FFFF&lt;/color&gt;&lt;!--亮青色 --&gt; &lt;color name="burlywood"&gt;#DEB887&lt;/color&gt;&lt;!--实木色 --&gt; &lt;color name="plum"&gt;#DDA0DD&lt;/color&gt;&lt;!--洋李色 --&gt; &lt;color name="gainsboro"&gt;#DCDCDC&lt;/color&gt;&lt;!--淡灰色 --&gt; &lt;color name="crimson"&gt;#DC143C&lt;/color&gt;&lt;!--暗深红色 --&gt; &lt;color name="palevioletred"&gt;#DB7093&lt;/color&gt;&lt;!--苍紫罗兰色 --&gt; &lt;color name="goldenrod"&gt;#DAA520&lt;/color&gt;&lt;!--金麒麟色 --&gt; &lt;color name="orchid"&gt;#DA70D6&lt;/color&gt;&lt;!--淡紫色 --&gt; &lt;color name="thistle"&gt;#D8BFD8&lt;/color&gt;&lt;!--蓟色 --&gt; &lt;color name="lightgray"&gt;#D3D3D3&lt;/color&gt;&lt;!--亮灰色 --&gt; &lt;color name="lightgrey"&gt;#D3D3D3&lt;/color&gt;&lt;!--亮灰色 --&gt; &lt;color name="tan"&gt;#D2B48C&lt;/color&gt;&lt;!--茶色 --&gt; &lt;color name="chocolate"&gt;#D2691E&lt;/color&gt;&lt;!--巧可力色 --&gt; &lt;color name="peru"&gt;#CD853F&lt;/color&gt;&lt;!--秘鲁色 --&gt; &lt;color name="indianred"&gt;#CD5C5C&lt;/color&gt;&lt;!--印第安红 --&gt; &lt;color name="mediumvioletred"&gt;#C71585&lt;/color&gt;&lt;!--中紫罗兰色 --&gt; &lt;color name="silver"&gt;#C0C0C0&lt;/color&gt;&lt;!--银色 --&gt; &lt;color name="darkkhaki"&gt;#BDB76B&lt;/color&gt;&lt;!--暗黄褐色 --&gt; &lt;color name="rosybrown"&gt;#BC8F8F&lt;/color&gt;&lt;!--褐玫瑰红 --&gt; &lt;color name="mediumorchid"&gt;#BA55D3&lt;/color&gt;&lt;!--中粉紫色 --&gt; &lt;color name="darkgoldenrod"&gt;#B8860B&lt;/color&gt;&lt;!--暗金黄色 --&gt; &lt;color name="firebrick"&gt;#B22222&lt;/color&gt;&lt;!--火砖色 --&gt; &lt;color name="powderblue"&gt;#B0E0E6&lt;/color&gt;&lt;!--粉蓝色 --&gt; &lt;color name="lightsteelblue"&gt;#B0C4DE&lt;/color&gt;&lt;!--亮钢兰色 --&gt; &lt;color name="paleturquoise"&gt;#AFEEEE&lt;/color&gt;&lt;!--苍宝石绿 --&gt; &lt;color name="greenyellow"&gt;#ADFF2F&lt;/color&gt;&lt;!--黄绿色 --&gt; &lt;color name="lightblue"&gt;#ADD8E6&lt;/color&gt;&lt;!--亮蓝色 --&gt; &lt;color name="darkgray"&gt;#A9A9A9&lt;/color&gt;&lt;!--暗灰色 --&gt; &lt;color name="darkgrey"&gt;#A9A9A9&lt;/color&gt;&lt;!--暗灰色 --&gt; &lt;color name="brown"&gt;#A52A2A&lt;/color&gt;&lt;!--褐色 --&gt; &lt;color name="sienna"&gt;#A0522D&lt;/color&gt;&lt;!--赭色 --&gt; &lt;color name="darkorchid"&gt;#9932CC&lt;/color&gt;&lt;!--暗紫色 --&gt; &lt;color name="palegreen"&gt;#98FB98&lt;/color&gt;&lt;!--苍绿色 --&gt; &lt;color name="darkviolet"&gt;#9400D3&lt;/color&gt;&lt;!--暗紫罗兰色 --&gt; &lt;color name="mediumpurple"&gt;#9370DB&lt;/color&gt;&lt;!--中紫色 --&gt; &lt;color name="lightgreen"&gt;#90EE90&lt;/color&gt;&lt;!--亮绿色 --&gt; &lt;color name="darkseagreen"&gt;#8FBC8F&lt;/color&gt;&lt;!--暗海兰色 --&gt; &lt;color name="saddlebrown"&gt;#8B4513&lt;/color&gt;&lt;!--重褐色 --&gt; &lt;color name="darkmagenta"&gt;#8B008B&lt;/color&gt;&lt;!--暗洋红 --&gt; &lt;color name="darkred"&gt;#8B0000&lt;/color&gt;&lt;!--暗红色 --&gt; &lt;color name="blueviolet"&gt;#8A2BE2&lt;/color&gt;&lt;!--紫罗兰蓝色 --&gt; &lt;color name="lightskyblue"&gt;#87CEFA&lt;/color&gt;&lt;!--亮天蓝色 --&gt; &lt;color name="skyblue"&gt;#87CEEB&lt;/color&gt;&lt;!--天蓝色 --&gt; &lt;color name="gray"&gt;#808080&lt;/color&gt;&lt;!--灰色 --&gt; &lt;color name="grey"&gt;#808080&lt;/color&gt;&lt;!--灰色 --&gt; &lt;color name="olive"&gt;#808000&lt;/color&gt;&lt;!--橄榄色 --&gt; &lt;color name="purple"&gt;#800080&lt;/color&gt;&lt;!--紫色 --&gt; &lt;color name="maroon"&gt;#800000&lt;/color&gt;&lt;!--粟色 --&gt; &lt;color name="aquamarine"&gt;#7FFFD4&lt;/color&gt;&lt;!--碧绿色 --&gt; &lt;color name="chartreuse"&gt;#7FFF00&lt;/color&gt;&lt;!--黄绿色 --&gt; &lt;color name="lawngreen"&gt;#7CFC00&lt;/color&gt;&lt;!--草绿色 --&gt; &lt;color name="mediumslateblue"&gt;#7B68EE&lt;/color&gt;&lt;!--中暗蓝色 --&gt; &lt;color name="lightslategray"&gt;#778899&lt;/color&gt;&lt;!--亮蓝灰 --&gt; &lt;color name="lightslategrey"&gt;#778899&lt;/color&gt;&lt;!--亮蓝灰 --&gt; &lt;color name="slategray"&gt;#708090&lt;/color&gt;&lt;!--灰石色 --&gt; &lt;color name="slategrey"&gt;#708090&lt;/color&gt;&lt;!--灰石色 --&gt; &lt;color name="olivedrab"&gt;#6B8E23&lt;/color&gt;&lt;!--深绿褐色 --&gt; &lt;color name="slateblue"&gt;#6A5ACD&lt;/color&gt;&lt;!--石蓝色 --&gt; &lt;color name="dimgray"&gt;#696969&lt;/color&gt;&lt;!--暗灰色 --&gt; &lt;color name="dimgrey"&gt;#696969&lt;/color&gt;&lt;!--暗灰色 --&gt; &lt;color name="mediumaquamarine"&gt;#66CDAA&lt;/color&gt;&lt;!--中绿色 --&gt; &lt;color name="cornflowerblue"&gt;#6495ED&lt;/color&gt;&lt;!--菊兰色 --&gt; &lt;color name="cadetblue"&gt;#5F9EA0&lt;/color&gt;&lt;!--军兰色 --&gt; &lt;color name="darkolivegreen"&gt;#556B2F&lt;/color&gt;&lt;!--暗橄榄绿 --&gt; &lt;color name="indigo"&gt;#4B0082&lt;/color&gt;&lt;!--靛青色 --&gt; &lt;color name="mediumturquoise"&gt;#48D1CC&lt;/color&gt;&lt;!--中绿宝石 --&gt; &lt;color name="darkslateblue"&gt;#483D8B&lt;/color&gt;&lt;!--暗灰蓝色 --&gt; &lt;color name="steelblue"&gt;#4682B4&lt;/color&gt;&lt;!--钢兰色 --&gt; &lt;color name="royalblue"&gt;#4169E1&lt;/color&gt;&lt;!--皇家蓝 --&gt; &lt;color name="turquoise"&gt;#40E0D0&lt;/color&gt;&lt;!--青绿色 --&gt; &lt;color name="mediumseagreen"&gt;#3CB371&lt;/color&gt;&lt;!--中海蓝 --&gt; &lt;color name="limegreen"&gt;#32CD32&lt;/color&gt;&lt;!--橙绿色 --&gt; &lt;color name="darkslategray"&gt;#2F4F4F&lt;/color&gt;&lt;!--暗瓦灰色 --&gt; &lt;color name="darkslategrey"&gt;#2F4F4F&lt;/color&gt;&lt;!--暗瓦灰色 --&gt; &lt;color name="seagreen"&gt;#2E8B57&lt;/color&gt;&lt;!--海绿色 --&gt; &lt;color name="forestgreen"&gt;#228B22&lt;/color&gt;&lt;!--森林绿 --&gt; &lt;color name="lightseagreen"&gt;#20B2AA&lt;/color&gt;&lt;!--亮海蓝色 --&gt; &lt;color name="dodgerblue"&gt;#1E90FF&lt;/color&gt;&lt;!--闪兰色 --&gt; &lt;color name="midnightblue"&gt;#191970&lt;/color&gt;&lt;!--中灰兰色 --&gt; &lt;color name="aqua"&gt;#00FFFF&lt;/color&gt;&lt;!--浅绿色 --&gt; &lt;color name="cyan"&gt;#00FFFF&lt;/color&gt;&lt;!--青色 --&gt; &lt;color name="springgreen"&gt;#00FF7F&lt;/color&gt;&lt;!--春绿色 --&gt; &lt;color name="lime"&gt;#00FF00&lt;/color&gt;&lt;!--酸橙色 --&gt; &lt;color name="mediumspringgreen"&gt;#00FA9A&lt;/color&gt;&lt;!--中春绿色 --&gt; &lt;color name="darkturquoise"&gt;#00CED1&lt;/color&gt;&lt;!--暗宝石绿 --&gt; &lt;color name="deepskyblue"&gt;#00BFFF&lt;/color&gt;&lt;!--深天蓝色 --&gt; &lt;color name="darkcyan"&gt;#008B8B&lt;/color&gt;&lt;!--暗青色 --&gt; &lt;color name="teal"&gt;#008080&lt;/color&gt;&lt;!--水鸭色 --&gt; &lt;color name="green"&gt;#008000&lt;/color&gt;&lt;!--绿色 --&gt; &lt;color name="darkgreen"&gt;#006400&lt;/color&gt;&lt;!--暗绿色 --&gt; &lt;color name="blue"&gt;#0000FF&lt;/color&gt;&lt;!--蓝色 --&gt; &lt;color name="mediumblue"&gt;#0000CD&lt;/color&gt;&lt;!--中兰色 --&gt; &lt;color name="darkblue"&gt;#00008B&lt;/color&gt;&lt;!--暗蓝色 --&gt; &lt;color name="navy"&gt;#000080&lt;/color&gt;&lt;!--海军色 --&gt; &lt;color name="black"&gt;#000000&lt;/color&gt;&lt;!--黑色 --&gt;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android.widget.RelativeLayout$LayoutParams cannot be cast to android.widget.FrameLayout$LayoutParams]]></title>
    <url>%2F2016%2F12%2F03%2Fandroid.widget.RelativeLayout%24LayoutParams%20cannot%20be%20cast%20to%20android.widget.FrameLayout%24LayoutParams%2F</url>
    <content type="text"><![CDATA[java.lang.ClassCastException: android.widget.RelativeLayout$LayoutParams cannot be cast to android.widget.FrameLayout$LayoutParams 错误的解决办法 FrameLayout的父控件是一个LinearLayout控件，问题出在，LinearLayout为子控件分配空间的时候，获取FrameLayout的LayoutParams的必须为LinearLayout.LayoutParams，而非FrameLayout.LayoutParams。 简单的举个栗子说明一下：最外层有ReLativeLayout A，里面有两个LinearLayout B、C，而B中又有一个一个FrameLayout D。如果要在代码里设置B的LayoutParams,B的LayoutParams要为RelativeLayout.LayoutParams。12RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);B.setLayoutParams(params); 而D要设置的话，需要：123LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, 0);params.weight = 8;D.setLayoutParams(params); 而笔者是直接使用的最外层的RelativeLayout，它的外层不是RelativeLayout了，导致笔者的代码一直报标题的错误 所以笔者就在最外层的RelativeLayout放入了一个RelativeLayout_inside，然后再把自定义view放入RelativeLayout_inside，现在RelativeLayout_inside的外层就是RelativeLayout了，错误也就消失了。 现记录，引以为戒]]></content>
      <tags>
        <tag>Android</tag>
        <tag>FrameLayout</tag>
        <tag>LinearLayout</tag>
        <tag>RelativeLayout</tag>
      </tags>
  </entry>
</search>
